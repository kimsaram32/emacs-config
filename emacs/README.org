# -*- lexical-binding:t; -*-
#+startup: fold
#+startup: hideblocks
#+property: header-args:elisp :results silent :lexical t
* Packages
** Use Melpa
#+begin_src elisp
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
#+end_src
** Setup Custom
#+begin_src elisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(load custom-file)
#+end_src
** Install
#+begin_src elisp
  (require 'flymake)
  (require 'cc-mode)
  (require 'yaml-mode)
  (require 'org)
  (require 'org-agenda)
  (require 'org-capture)
  (require 'org-journal)
  (require 'org-super-agenda)
  (require 'org-ql)
  (require 'org-social)
  (require 'org-bookmark-heading)
  (require 'rg)
  (require 'elfeed)
  (require 'modus-themes)
  (require 'evil)
  (require 'magit)
  (require 'vterm)
  (require 'rfc-mode)
  (require 'auctex)
  (require 'cdlatex)
  (require 'markdown-mode)
  (require 'company)
  (require 'format-all)
  (require 'eglot-booster)
#+end_src
* Environment
** Workaround: =Invalid function: org-element-with-disabled-cache=
[[https://www.reddit.com/r/emacs/comments/1hayavx/invalid_function_orgelementwithdisabledcache/][Reddit]]
#+begin_src elisp
  (setq native-comp-jit-compilation-deny-list '(".*org-element.*")) 
#+end_src
** exec-path-from-shell
#+begin_src elisp
(when (memq window-system '(mac ns x))
  (exec-path-from-shell-initialize))
#+end_src
** Enable disabled commands
#+begin_src elisp
(put 'scroll-left 'disabled nil)
#+end_src
** macOS keyboard
#+begin_src elisp
  (setq mac-option-modifier 'meta)
#+end_src
* Repeated key bindings
From [[https://karthinks.com/software/persistent-prefix-keymaps-in-emacs/][Persistent prefifx keymaps in Emacs]]
#+begin_src elisp
  (defun me:repeated-prefix-help-command ()
    (interactive)
    (when-let* ((keys (this-command-keys-vector))
                (prefix (seq-take keys (1- (length keys))))
                (orig-keymap (key-binding prefix t))
                (keymap (copy-keymap orig-keymap)))
      (setq me:transient-map--exit-func (set-transient-map keymap t nil "Repeating"))
      (define-key keymap [remap keyboard-quit]
        		  (lambda ()
        		    (interactive)
        		    (funcall me:transient-map--exit-func)))
      (keymap-set keymap "C-h"
  		(lambda ()
  		  (interactive)
  		  (funcall me:transient-map--exit-func)
  		  (describe-bindings prefix)))))

  (setq prefix-help-command #'me:repeated-prefix-help-command)
#+end_src
* Apropos key bindings
#+begin_src elisp
(unbind-key "a" help-map)

(keymap-set help-map "a a" 'apropos-command)
(keymap-set help-map "a f" 'apropos-function)
(keymap-set help-map "a v" 'apropos-variable)
(keymap-set help-map "a u" 'apropos-user-option)
(keymap-set help-map "a l" 'apropos-library)
#+end_src
* Use short answers
#+begin_src elisp
  (setq use-short-answers t)
#+end_src
* Constants
** Directories
#+begin_src elisp
  (defconst me:dotfiles-directory (expand-file-name "~/me/dotfiles")
    "Root directory for dotfiles.")

  (defconst me:note-root-directory (expand-file-name "~/me/myself/")
    "Root directory for notes.")

  (defconst me:note-periodic-directory
    (file-name-concat me:note-root-directory "life/")
    "Directory for periodic notes.")

  (defconst me:note-project-directory
    (file-name-concat me:note-root-directory "projects/")
    "Directory for projects.")

  (defconst me:note-zk-directory
    (file-name-concat me:note-root-directory "zk/")
    "Directory for Zettelkasten.")

  (defconst me:note-media-directory
    (file-name-concat me:note-root-directory "media/")
    "Directory for media (e.g. images)")
#+end_src
** Starting hour of a day
#+begin_src elisp
(defconst me:note-day-start-hour 3 "The starting hour of a day for notes.")
#+end_src
** Get current day for the note system
#+begin_src elisp
(defun me:note-current-date ()
  "Return current time value for the note system. If the time is before
`me:note-day-start-hour', return yesterday's date. Otherwise, return
today's date."
  (let* ((time (decode-time))
	 (current-day (decoded-time-day time))
	 (day (if (< (decoded-time-hour time) me:note-day-start-hour)
		  (- current-day 1)
		current-day)))
    (encode-time (append (list 0 0 0 day) (seq-subseq time 4)))))
#+end_src
** Zettelkasten
Moved here to resolve cyclic dependency between Org Mode and ZK
#+begin_src elisp
  (defconst me:zettel-id-format
    "%Y%m%d%H%M"
    "The format for zettel IDs.")

  (defconst me:zk-backlinks-buffer-name
    "*ZK Backlinks*"
    "Buffer name for displaying ZK backlinks.")
#+end_src
* UI and Display
** Remove bars
#+begin_src elisp
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
#+end_src
** Set transparent title bars
#+begin_src elisp
  (set-frame-parameter nil 'ns-transparent-toolbar t)
  (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
#+end_src
** Title bar text
#+begin_src elisp
  (setq-default frame-title-format "")
#+end_src
** Font faces
*** Enable fixed windows
Before customizing fonts, temporarily enable fixed windows
to prevent resizing windows when changing fonts.
#+begin_src elisp
(setq-default window-size-fixed t)
#+end_src
*** Font faces
#+begin_src elisp
(set-face-attribute 'default nil
		    :height 160
		    :family "JetBrains Mono")
(set-face-attribute 'variable-pitch nil
		    :height 170
		    :family "Helvetica Neue")
#+end_src
*** Disable fixed windows
#+begin_src elisp
(setq-default window-size-fixed nil)
#+end_src
** Line height
#+begin_src elisp
(setq-default line-spacing 2)
#+end_src
* Editing
** Tab bar mode
#+begin_src elisp
(tab-bar-mode)
(keymap-global-set "C-c <SPC>" tab-prefix-map)
(keymap-set tab-prefix-map "]" 'tab-next)
(keymap-set tab-prefix-map "[" 'tab-previous)
(setq tab-bar-auto-width-max '((140) 20))
#+end_src
** Visual line mode
#+begin_src elisp
(visual-line-mode)
#+end_src
** Sentences
#+begin_src elisp
  (setq sentence-end-double-space nil)
  (setq sentence-end-base "[.?!…‽,][]\"'”’)}»›]*")
#+end_src
** Mark ring
#+begin_src elisp
(setq set-mark-command-repeat-pop t)
#+end_src
** Registers
#+begin_src elisp
  (setopt register-use-preview 'insist)
#+end_src
** Insert quotes more easily
#+begin_src elisp
(defun me:insert-quotes (&optional arg)
  "Like `insert-parentheses`, but for quotes."
  (interactive "P")
  (insert-pair arg ?\" ?\"))
(keymap-global-set "M-\"" 'me:insert-quotes)
#+end_src
** Clear empty lines
#+begin_src elisp
  (defun me:clear-empty-lines ()
    "Clear empty lines on current buffer.

  When region is activated, operat on that region."
    (interactive)
    (save-restriction
      (save-excursion
        (when (use-region-p)
          (narrow-to-region (region-beginning) (region-end)))
        (goto-char (point-min))
        (delete-matching-lines "^$"))))
#+end_src
** Delete pair
#+begin_src elisp
(setq delete-pair-blink-delay 0)
(keymap-global-set "C-M-z" 'delete-pair)
#+end_src
* Windows
** Display-buffer
#+begin_src elisp
  (setq switch-to-buffer-obey-display-actions t)
#+end_src
** Winner mode
#+begin_src elisp
  (winner-mode)
#+end_src
* Buffers
** Default scratch buffer message
#+begin_src elisp
(setq initial-scratch-message "\
;; Hi this is a scratch buffer

")
#+end_src
** Short for switching previous/next buffer
#+begin_src elisp
(keymap-global-set "C-c b l" 'previous-buffer)
(keymap-global-set "C-c b r" 'next-buffer)
#+end_src
** Helper function: delete current buffer's file
#+begin_src elisp
(defun me:delete-current-file ()
  "Delete current buffer's file."
  (interactive)
  (delete-file (buffer-file-name)))
#+end_src
* Workflow
** Finish today
#+begin_src elisp
  (defconst me:personal-git-repositories
    `((,me:dotfiles-directory . "dotfiles")
      (,me:note-root-directory . "notes"))
    "Git repositories for personal workflow.
  Used by `me:finish-today' for automatic daily commits.")

  (defun me:finish-today ()
    "Finish daily workflow; save all buffers associated with a file, commit
  changes in personal repositories."
    (interactive)
    (save-some-buffers t)
    (dolist (repo me:personal-git-repositories)
      (let ((name (cdr repo))
  	  (default-directory (car repo))
  	  (subcommands `(("add" ".")
  			 ("commit" "-m"
  			  ,(format-time-string "%Y%m%d" (me:note-current-date)))
  			 ("push"))))
        (dolist (args subcommands)
  	(apply 'call-process (append '("git" nil nil nil) args)))
        (message (format "Commited and pushed changes in %s." name))))
    (message "Done. Good night :)"))
#+end_src
* Migration
** Migrate inline latex
#+begin_src elisp
(defun me:migrate-latex ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward "\\$\\(.+?\\)\\$" nil t)
      (replace-match "\\\\(\\1\\\\)"))))
(keymap-global-set "C-c m l" 'me:migrate-latex)
#+end_src
** Check if the current line is empty
Helper function for migration command
#+begin_src elisp
(defun is-empty-line-p ()
  "Return t if current line only includes whitespace, else return
nil."
  (not (not (string-match-p "^[[:blank:]]*$"
        (buffer-substring (line-beginning-position)
                          (line-end-position))))))
#+end_src
** Remove empty lines before/after headings
#+begin_src elisp
  ;; this is a quite hacky implementation; fix later
  (defun me:org-remove-empty-lines-around-headings ()
    "Remove empty lines before and after each headings."
    (interactive)
    (org-map-entries
       (lambda ()
         (forward-line -1)
         (when (is-empty-line-p)
           (insert "##delete##"))
         (forward-line 2)
         (when (is-empty-line-p)
           (insert "##delete##")))
       nil (if (region-active-p) 'region nil))
    (delete-matching-lines "##delete##"))

  (keymap-global-set "C-c m h" 'me:org-remove-empty-lines-around-headings)
#+end_src
** Migrate old Org mode documents
#+begin_src elisp
(defun me:migrate-org-properties ()
  "Migrate current old Org document to follow the new format. Specifically:
- move incorrect buffer options (created and updated) into properties.
- if ZK, call `me:set-zettel-id-property'.
- Move filetags into entry tags."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (let ((created-at (and (re-search-forward "^#\\+created: \\(.+\\)$" nil t)
			   (let ((val (match-string 1)))
			     (beginning-of-line)
			     (delete-line)
			     val)))
	  (updated-at (and (re-search-forward "^#\\+updated: \\(.+\\)$" nil t)
			   (let ((val (match-string 1)))
			     (beginning-of-line)
			     (delete-line)
			     val)))
	  (filetags (and (re-search-forward "^#\\+filetags: \\(.+\\)$" nil t)
			   (let ((val (match-string 1)))
			     (beginning-of-line)
			     (delete-line)
			     val))))
      (org-next-visible-heading 1)
      (when created-at (org-set-property "created" created-at))
      (when updated-at (org-set-property "updated" updated-at))
      (when filetags (org-set-tags (string-replace "-" "_" filetags))))
    (me:set-zettel-id-property)))
#+end_src
** Migration from markdown
Previously, I used plain markdown documents for note taking.
Now I have to migrate from it.

I chose incremental migration. When I see a markdown note, I
explicitly call the migration command to convert to Org format. I
wanted more fine-grained control over my notes, so I needed to verify
the correctness of the conversion result.
*** Pandoc migration command
The path to the lua filter is hardcoded. This could be improved.

#+begin_src elisp
(defvar me:pandoc-migration-command
  "pandoc --wrap=preserve -f commonmark+task_lists+yaml_metadata_block -s -t org --lua-filter=/Users/kimsaram32/me/myself/pandoc-filter.lua"
  "Command to use for `me:migrate-to-org'.")
#+end_src
*** Convert from markdown to Org
#+begin_src elisp
  (defun me:migrate-markdown-to-org ()
    "Convert current markdown file into Org Mode document, using Pandoc.
  Open the converted document in current buffer.
  Perform the following transformations:
  - move frontmatters (created and updated) into properties.
  - if ZK, transform links and add custom_id property.
  - if non-ZK, remove links as they are broken."
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (let* ((input-buffer (current-buffer))
  	   (input-file-name (buffer-file-name))
  	   (created-at (when (re-search-forward "^created: \\(.+\\)$" nil t)
  			 (match-string 1)))
  	   (updated-at (when (re-search-forward "^updated: \\(.+\\)$" nil t)
  			 (match-string 1)))
  	   (is-zk (me:is-zettel-name-p input-file-name)))
        (save-buffer)
        
        (with-temp-buffer
  	(call-process-shell-command me:pandoc-migration-command input-file-name t)
  	(let ((temp-buffer (current-buffer)))
  	  (with-current-buffer input-buffer
  	    (replace-buffer-contents temp-buffer))))
        (goto-char (point-min))
        (when is-zk
  	(let ((tags))
  	  (while (re-search-forward "#\\([A-z0-9가-힣\\-]+\\)" nil t)
  	    (push (string-replace "-" "_" (match-string 1)) tags)
  	    (let ((start (match-beginning 0))
  		  (end (match-end 0)))
  	      (delete-region start end)
  	      (goto-char start)
  	      (beginning-of-line)
  	      (when (looking-at "^[[:space:]]*$")
  		(delete-line))))
  	  (org-next-visible-heading 1)
  	  (org-set-tags tags)))
        (goto-char (point-min))
        (org-next-visible-heading 1)
        (when created-at
  	(org-set-property "created" created-at))
        (when updated-at
  	(org-set-property "updated" updated-at))
        
        (if is-zk
  	  (progn
  	    (me:set-zettel-id-property)
  	    (save-excursion
  	      (replace-regexp "\\[\\[\\([0-9]+\\)]]" "[[id:\\1][\\1]]")))
  	(save-excursion
  	  (replace-regexp "\\[\\[\\(.+?\\)\\]\\]" "\\1"))))))
#+end_src
*** Change verbatim to code
Pandoc produces verbatim (=) in place of markdown code (`), but I
prefer to use code (~).
#+begin_src elisp
(defun me:verbatim-to-code ()
  (interactive)
  (replace-regexp "=" "~"))
(keymap-global-set "C-c m c" 'me:verbatim-to-code)
#+end_src
** Migration from Obsidian documents
#+begin_src elisp
  (defun me:migrate-insert-capture-heading ()
    "Insert heading from current buffer's name."
    (interactive)
    (let* ((split (string-split (file-name-base (buffer-name))))
  	 (time (date-to-time (nth 0 split)))
  	 (name (string-join (cdr split) " ")))
      (insert "* " (format-time-string "<%Y-%m-%d> " time) name)))
#+end_src
** Automatic migration
*** Markdown indicator string
I renamed all *.md documents to *.org for easier file searching and
file name resolutions.

To distinguish old markdown documents, I included fixed indicator
strings to them.

#+begin_src elisp
(defconst me:markdown-indicator-string ""
  "String that indicates the current file is a markdown document.")
#+end_src
*** DWIM migration
#+begin_src elisp
  (defun me:migrate-dwim ()
    "Migrate current file. DWIM."
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (if (search-forward me:markdown-indicator-string nil t)
  	(progn
  	  (replace-match "" nil t)
  	  (while (search-forward me:markdown-indicator-string nil t)
  	    (replace-match "" nil t))
  	  (me:migrate-markdown-to-org))
        (me:migrate-org-properties)
        (me:migrate-latex)
        (me:org-remove-empty-lines-around-headings))))
  (keymap-global-set "C-c m m" 'me:migrate-dwim)
#+end_src
* Programming
Current stack is:
- Eglot for LSP client and general editor features
- Format-all for formatting
- Flymake for diagnostics and syntax checking
- Xref
- Company-mode for autocompletion
- Emacs projects for workspace management

** Eglot
#+begin_src elisp
  (keymap-set prog-mode-map "C-c C-r" #'eglot-rename)
#+end_src
** Disable tabs
#+begin_src elisp
  (setq-default indent-tabs-mode nil)
#+end_src
** Flymake
*** Next and previous error
#+begin_src elisp
  (keymap-set flymake-mode-map "M-n" 'flymake-goto-next-error)
  (keymap-set flymake-mode-map "M-p" 'flymake-goto-prev-error)
#+end_src
** Company-mode
#+begin_src elisp
  (add-hook 'prog-mode-hook #'company-mode)
#+end_src
*** Active key bindings
#+begin_src elisp
  (keymap-set company-active-map "M-TAB" #'company-complete-selection)
  (keymap-set company-active-map "M-n" #'company-select-next-or-abort)
  (keymap-set company-active-map "M-p" #'company-select-previous-or-abort)
  (keymap-set company-active-map "M-h" #'company-show-doc-buffer)
#+end_src
*** Global key bindings
#+begin_src elisp
  (keymap-global-set "C-M-i" #'company-complete)
#+end_src
*** Prog-mode key bindings
Language major modes override key sequences I want to use,
so bind them using a minor mode.
#+begin_src elisp
  (defvar-keymap me:prog-override-mode-map
    :doc "Keymap for prog-mode overrides."
    "M-TAB" #'company-complete)

  (define-minor-mode me:prog-override-mode
    "Minor mode for overriding some prog-mode key bindings."
    :lighter "")

  (add-hook 'prog-mode-hook #'me:prog-override-mode)
#+end_src
*** Idle delay
#+begin_src elisp
  (setq company-idle-delay 0)
#+end_src
** Python
*** Set shell interpreter
#+begin_src elisp
(setq python-shell-interpreter "python3")
#+end_src
** C Mode
#+begin_src elisp
  (setq c-default-style "bsd")

  (defun me:cc-mode-set-offset ()
    (setq c-basic-offset 2))

  (add-hook 'cc-mode-hook #'me:cc-mode-set-offset)
  (add-hook 'c++-mode-hook #'me:cc-mode-set-offset)
#+end_src
*** Go to the body of the next defun
#+begin_src elisp
  (defun me:c-previous-defun-body ()
    "Go to body of the previous defun."
    (interactive)
    (if (c-defun-name)
        (c-beginning-of-defun))
    (c-beginning-of-defun)
    (c-syntactic-re-search-forward "{"))

  (defun me:c-next-defun-body ()
    "Go to body of the next defun."
    (interactive)
    (if (c-defun-name)
        (c-end-of-defun))
    (c-syntactic-re-search-forward "{"))

  (keymap-set c-mode-map "C-M-x" 'me:c-next-defun-body)
  (keymap-set c-mode-map "C-M-y" 'me:c-previous-defun-body)
#+end_src
** JavaScript
#+begin_src elisp
  (setq js-indent-level 2)
#+end_src
** Yaml
#+begin_src elisp
  (add-to-list 'auto-mode-alist '("\\.yml\\'" . yaml-mode))
#+end_src
** Format-all
#+begin_src elisp
  (keymap-set prog-mode-map "C-c C-f" #'format-all-region-or-buffer)
#+end_src
* Zettelkasten
Depends on Org mode.
** Zettel file name regex
#+begin_src elisp
  (defconst me:zettel-file-name-regex
    "zk-.+?\\.org$"
    "Regex for matching zettel file names.")
#+end_src
** ZK Major mode
#+begin_src elisp
  (define-derived-mode me:zk-mode
    org-mode "Zettelkasten"
    "Major mode for Zettels.")

  (add-to-list 'auto-mode-alist `(,me:zettel-file-name-regex . me:zk-mode))
#+end_src
** helper: Goto top level heading
#+begin_src elisp
(defun me:org-goto-top-level-heading ()
  "Goto upmost heading."
  (interactive)
  (while (org-up-heading-safe) nil))
#+end_src
** Predicate for zettel file names
#+begin_src elisp
  (defun me:is-zettel-name-p (name)
    "Return t if NAME is a file name to a zettel. else return nill."
    (string-match-p me:zettel-file-name-regex name))
#+end_src
** Get zettel timestamp
#+begin_src elisp
(defun me:get-zettel-timestamp ()
  "Get zettel timestamp for current time."
  (format-time-string me:zettel-id-format))
#+end_src
** Get zettel id for current entry
#+begin_src elisp
  (defun me:entry-zettel-id ()
    "Return the zettel ID of current entry."
    (save-excursion
      (me:org-goto-top-level-heading)
      (let ((properties (org-entry-properties (point))))
        (cdr (or (assoc "id" properties)
  	       (assoc "ID" properties))))))

  (defun me:entry-zettel-id-as-link ()
    "Return the zettel ID of current entry as Org link format."
    (interactive)
    (let ((id (me:entry-zettel-id)))
      (message id)
      (format "[[id:%s][%s]]" id id)))

  (keymap-set me:zk-mode-map "C-c z l" (lambda ()
    				       (interactive)
    				       (kill-new (me:entry-zettel-id-as-link))))
#+end_src

Integrate with Org agenda mode.

#+begin_src elisp
  (defun me:copy-zettel-link-in-agenda ()
    "Add the zettel link to the kill ring from org-agenda-mode."
    (interactive)
    (let* ((marker (or (org-get-at-bol 'org-marker)
  		     (org-agenda-error)))
  	 (buffer (marker-buffer marker))
  	 (pos (marker-position marker)))
      (with-current-buffer buffer 
        (widen)
        (goto-char pos)
        (kill-new (me:entry-zettel-id-as-link)))))

  (keymap-set org-agenda-mode-map "C-c z l" 'me:copy-zettel-link-in-agenda)
#+end_src
** Managing properties
*** Set the ID property
#+begin_src elisp
  (defun me:set-zettel-id-property ()
    "Set zettel ID of the current entry, if it's not set."
    (interactive)
    (save-excursion
      (me:org-goto-top-level-heading)
      (unless (org-entry-get (point) "id")
        (org-entry-put (point) "ID" (me:get-zettel-timestamp)))))
#+end_src
*** Set date properties
#+begin_src elisp
  (defun me:set-date-properties ()
    "Update the 'updated' property of current buffer as current date.
  Also update the 'created' property if one does not exist."
    (interactive)
    (let ((date-string (format-time-string "%Y-%m-%d" (me:note-current-date))))
      (save-excursion
        (me:org-goto-top-level-heading)
        (unless (org-entry-get (point) "created")
  	(org-set-property "created" date-string))
        (org-set-property "updated" (concat "<" date-string ">"))))
    (message "Set date properties"))
#+end_src
*** Set all zettel properties
#+begin_src elisp
(defun me:set-zettel-properties ()
  "Call `me:set-date-properties' and `me:set-zettel-id-property'."
  (interactive)
  (me:set-date-properties)
  (me:set-zettel-id-property))
(keymap-global-set "C-c z u" 'me:set-zettel-properties)
#+end_src
** Backlinks
#+begin_src elisp
  (defun me:zettel-search-backlinks ()
    "Search for ZK backlinks for current entry."
    (interactive)
    (org-ql-search (org-agenda-files)
      `(regexp ,(me:entry-zettel-id))
      :title "Backlinks"
      :buffer "*ZK Backlinks*"))

  (keymap-global-set "C-c z b" 'me:zettel-search-backlinks)
#+end_src
** Registers
Create a custom register type.
#+begin_src elisp
  (cl-defstruct zk-zettel-register
    id)

  (cl-defmethod register--type ((_regval zk-zettel-register)) 'zettel)

  (cl-defmethod register-val-jump-to ((val zk-zettel-register) _arg)
    (org-id-goto (zk-zettel-register-id val)))

  (cl-defmethod register-val-describe ((val zk-zettel-register) _verbose)
    (let* ((id (zk-zettel-register-id val))
           (marker (org-id-find id 'marker))
           (heading (if marker
                        (with-current-buffer (marker-buffer marker)
                          (save-excursion
                            (goto-char marker)
                            (org-get-heading t t t t)))
                      "Entry not found")))
      (princ (format "a zettel: %s (%s)" heading id))))

  (cl-defmethod register-val-insert ((val zk-zettel-register))
    (let ((id (zk-zettel-register-id val)))
      (insert (format "[[id:%s][%s]]" id id))))
#+end_src

Override register command info data. Need to find a better approach
#+begin_src elisp
  (cl-defmethod register-command-info ((_command (eql insert-register)))
    (make-register-preview-info
     :types '(string number zettel)
     :msg "Insert register `%s'"
     :act 'insert
     :smatch t
     :noconfirm (memq register-use-preview '(nil never))))

  (cl-defmethod register-command-info ((_command (eql jump-to-register)))
    (make-register-preview-info
     :types  '(window frame marker kmacro
               file buffer file-query zettel)
     :msg "Jump to register `%s'"
     :act 'jump
     :smatch t
     :noconfirm (memq register-use-preview '(nil never))))
#+end_src

Store current zettel to register, overriding default binding
#+begin_src elisp
  (defun zk-zettel-to-register (register)
    "Store current zettel at point in REGISTER.
  Interactively, prompt for REGISTER using `register-read-with-preview'."
    (interactive (list (register-read-with-preview
                        "Store zettel in register: ")))
    (add-hook 'kill-buffer-hook 'register-swap-out nil t)
    (set-register register (make-zk-zettel-register :id (me:entry-zettel-id))))

  (keymap-set me:zk-mode-map "C-x r SPC" #'zk-zettel-to-register)
#+end_src
** Jump to structure note
#+begin_src elisp
  (defun me:zk-show-structure-note (tag)
    "Show structure note for TAG."
    (interactive (list
  		(completing-read
  		 "Tag: "
  		 (org-global-tags-completion-table))))
    (when-let* ((result (org-ql-select
  			org-agenda-files
  			`(tags ,(concat "@" tag))
  			:action 'element-with-markers))
  	      (m (plist-get (nth 1 (car result)) :org-marker)))
      (pop-to-buffer-same-window (marker-buffer m))
      (goto-char m)
      (when (or (org-invisible-p) (org-invisible-p2)) (org-fold-show-context 'mark-goto))
      (recenter 0)))

  (keymap-global-set "C-c z s" #'me:zk-show-structure-note)
#+end_src
* Org mode
** Key bindings
*** Global bindings
#+begin_src elisp
  (keymap-global-set "C-c l" 'org-store-link)
  (keymap-global-set "C-c a" 'org-agenda)
  (keymap-global-set "C-c c" 'org-capture)
#+end_src
*** Move between paragraphs
#+begin_src elisp
  (keymap-set org-mode-map "M-{" 'org-backward-element)
  (keymap-set org-mode-map "M-}" 'org-forward-element)
#+end_src
*** Avoid arrow keys
I don't use a separate keyboard, so arrow keys are hard to press.
Remap arrow key commands to something else.

e.g. =M-<right>= is remapped to =C-c C-==.

#+begin_src elisp
  (keymap-set org-mode-map "C-c C--" #'org-metaup)
  (keymap-set org-mode-map "C-c C-=" #'org-metadown)
  (keymap-set org-mode-map "C-c C-;" #'org-metaleft)
  (keymap-set org-mode-map "C-c C-'" #'org-metaright)
#+end_src
*** Integrate with key repetitions
Those work well with repetitions.

#+begin_src elisp
  (keymap-set org-mode-map "C-c TAB" 'org-cycle)

  (keymap-set org-mode-map "C-c C-x &" 'org-mark-ring-goto)
  (keymap-set org-mode-map "C-c C-x C-o" 'org-open-at-point)
#+end_src
** Toggle subtree
#+begin_src elisp
  (defun me:org-toggle-subtree ()
    "Toggle all children of current heading."
    (interactive)
    (if (save-excursion
          (beginning-of-line)
          (outline-invisible-p (line-end-position)))
        (org-fold-show-subtree)
      (org-fold-hide-subtree)))
    
  (keymap-set org-mode-map "C-c C-x TAB" 'me:org-toggle-subtree)
  (keymap-set me:zk-mode-map "TAB" 'me:org-toggle-subtree)
#+end_src
** Goto
#+begin_src elisp
  (setq org-goto-auto-isearch nil)
  (setq org-goto-interface 'outline-path-completion)
#+end_src
** Directories
#+begin_src elisp
  (setq org-directory me:note-root-directory)
  (setq org-archive-location (expand-file-name
  			    "archives/%s.archive::"
  			    me:note-root-directory))
#+end_src
** File apps
#+begin_src elisp
(add-to-list 'org-file-apps '("\\.md\\'" . emacs))
#+end_src
** Starting hour of a day
- Sync with the core note taking system.
- Also used in org-journal.
#+begin_src elisp
(setq org-extend-today-until me:note-day-start-hour)
#+end_src
** Indent mode
Use indented headings.
#+begin_src elisp
(setq org-startup-indented t)
#+end_src
** Latex
*** LuaLaTeX
#+begin_src elisp
(setq luamagick '(luamagick :programs ("lualatex" "convert")
       :description "pdf > png"
       :message "you need to install lualatex and imagemagick."
       :use-xcolor t
       :image-input-type "pdf"
       :image-output-type "png"
       :image-size-adjust (1.0 . 1.0)
       :latex-compiler ("lualatex -interaction nonstopmode -output-directory %o %f")
       :image-converter ("convert -density %D -trim -antialias %f -quality 100 %O")))
(add-to-list 'org-preview-latex-process-alist luamagick)
#+end_src
*** dvisvgm
Dvisvgm configuration is patched for my environment...
#+begin_src elisp
(add-to-list 'org-preview-latex-process-alist
	     '(dvisvgm :programs ("latex" "dvisvgm") :description "dvi > svg"
		       :message
		       "you need to install the programs: latex and dvisvgm."
		       :image-input-type "dvi" :image-output-type "svg"
		       :image-size-adjust (1.7 . 1.5) :latex-compiler
		       ("latex -interaction nonstopmode -output-directory %o %f")
		       :image-converter
		       ("TEXMFCNF=\"/usr/local/texlive/2025:$TEXMFCNF\" dvisvgm --no-fonts --exact-bbox --scale=%S --output=%O --keep %f")))
#+end_src
*** Use dvisvgm for inline preview
#+begin_src elisp
(setq org-preview-latex-default-process 'dvisvgm)
#+end_src
*** Preview scaling
#+begin_src elisp
(plist-put org-format-latex-options :scale 2)
#+end_src
*** Image location
#+begin_src elisp
  (setq org-preview-latex-image-directory (expand-file-name "ltximg/" me:note-root-directory))
#+end_src
** New entry blanks
#+begin_src elisp
(setq org-blank-before-new-entry '((heading . auto) (plain-list-item auto)))
#+end_src
** Images
#+begin_src elisp
(setq org-startup-with-inline-images t)
(setq org-image-actual-width nil)
(setq org-image-max-width 400)
#+end_src
** Link abbrevations
#+begin_src elisp
  (setq org-link-abbrev-alist
        `(("zk" . ,(expand-file-name "id:%s" me:note-root-directory))
  	("media" . ,me:note-media-directory)))
#+end_src
** Tags
*** Tag inheritance
Exprimenting with this
#+begin_src elisp
  (setq org-use-tag-inheritance '("fleeting" "capture"))
#+end_src
** Todo
*** Todo keywords
#+begin_src elisp
  (setq org-todo-keywords
        '((sequence "TODO" "WORKING" "|" "DONE" "FAILED")))
  (setq org-todo-keyword-faces
        '(("TODO" . "gold")
  	("IDEA" . "coral")
  	("WORKING" . "CadetBlue2")
  	("FAILED" . "brown1")))
#+end_src
*** Deadine
#+begin_src elisp
(setq org-deadline-warning-days 21)
#+end_src
*** Priority
#+begin_src elisp
(setq org-priority-lowest 68
	org-priority-highest 65
	org-priority-default 68)
#+end_src
*** Enable habits
#+begin_src elisp
  (add-to-list 'org-modules 'habit)
#+end_src
** Editing source code
#+begin_src elisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((python . t)))
#+end_src
*** Remove source code indention
#+begin_src elisp
(setq org-edit-src-content-indentation 2)
#+end_src
** Org-id
*** ID format
Used to use timestamp here, but switched to use UUID (default).
ZK links are inserted not by org-id but a custom function.
Other entries should be inserted normal UUIDs to distinguish Zettels.
#+begin_src elisp
  (setq org-id-ts-format me:zettel-id-format)
  (setq org-id-method 'uuid)
#+end_src
*** Disable global tracking
#+begin_src elisp
(setq org-id-track-globally t)
#+end_src
** Org-agenda
*** Set files for agenda
#+begin_src elisp
  (setq org-agenda-files (list me:note-root-directory
  			     (expand-file-name "buffers/" me:note-root-directory)
  			     (expand-file-name "projects/" me:note-root-directory)
  			     me:note-zk-directory))
#+end_src
*** Window setup
#+begin_src elisp
  (setq org-agenda-restore-windows-after-quit t)
#+end_src
*** Periodic display options
#+begin_src elisp
(setq org-agenda-span 14)
#+end_src
*** Deadline options
#+begin_src elisp
  (setq org-agenda-todo-ignore-deadlines -1)
  (setq org-agenda-skip-deadline-prewarning-if-scheduled t)
  (setq org-agenda-skip-timestamp-if-deadline-is-shown t)
#+end_src
*** Sorting strategy
#+begin_src elisp
  (setq org-agenda-sorting-strategy
        '((agenda habit-up priority-down deadline-up category-keep)
  	(todo urgency-down category-keep)
  	(tags urgency-down category-keep)
  	(search category-keep)))
#+end_src
** Org-capture
*** Change finalize shortcut
I need to add tags inside the capture buffer.
#+begin_src elisp
  (keymap-unset org-capture-mode-map "C-c C-c")
  (keymap-set org-capture-mode-map "C-c C-f" 'org-capture-finalize)
#+end_src
** Org-babel
*** Disable confirmation
I know what I'm doing
#+begin_src elisp
(setq org-confirm-babel-evaluate nil)
#+end_src
*** Make the result keyword lowercased
#+begin_src elisp
(setq org-babel-results-keyword "results")
#+end_src
** Insert image from clipboard
#+begin_src elisp
  (defun me:insert-image-from-clipboard ()
    "Prompt for image file name, and create the image in `me:note-media-directory'.
  Insert the image at point as an Org mode link.

  With a prefix argument, do not insert the link and store it instead."
    (interactive)
    (let ((temp-file-name (make-temp-file "tmp-"))
          image-name)
      (when (not (eq 0 (call-process-shell-command
  		    (format "pngpaste %s" temp-file-name)
  		    nil nil)))
        (user-error "Attempted to paste non-image content"))
      (setq image-name (read-from-minibuffer "image name (with extensions): "))
      (copy-file temp-file-name
                 (expand-file-name image-name me:note-media-directory))
      (insert (format "[[media:%s]]" image-name))))

  (keymap-set org-mode-map "C-c i" #'me:insert-image-from-clipboard)
#+end_src
** I don't know what it does
todo
#+begin_src elisp
(setf (cdr (assoc 'file org-link-frame-setup)) 'find-file)
#+end_src
* Org-journal
** Key bindings
Custom lambda functions for opening today's journal file,
since creation of new entries is handled by org-capture.

#+begin_src elisp
  (setq org-journal-prefix-key "C-c j ")
  (keymap-global-set "C-c j j" (lambda ()
  			       (interactive)
  			       (org-journal-new-entry t)))
#+end_src
** Directory and files
#+begin_src elisp
(setq org-journal-dir me:note-periodic-directory)
(setq org-journal-file-format "%Y/%m/%Y-%m-%d.org")
#+end_src
** Date format
#+begin_src elisp
(setq org-journal-date-format "%Y-%m-%d")
#+end_src
** Time entry format
#+begin_src elisp
(setq org-journal-time-prefix "*** ")
(setq org-journal-time-format "<%R>")
#+end_src
** Opening entries
Use find-file to open journals in current window.
#+begin_src elisp
(setq org-journal-find-file-fn 'find-file)
#+end_src
** Disable carry over
Long-term todo items are already handled by my agenda workflow.
No need for carry overs.
#+begin_src elisp
(setq org-journal-carryover-items "")
#+end_src
* Org-super-agenda
#+begin_src elisp
  (org-super-agenda-mode)
#+end_src
* Org-social
#+begin_src elisp
  (setq org-social-file (expand-file-name "org_social_vfile" user-emacs-directory))
  (setq org-social-relay "https://relay.org-social.org/")
  (setq org-social-my-public-url "https://host.org-social.org/saram/social.org")
#+end_src
* Custom agendas
#+begin_src elisp
  (setq org-agenda-custom-commands nil)
#+end_src
** Daily agenda
#+begin_src elisp
  (add-to-list 'org-agenda-custom-commands
        '("d" "Daily agenda"
  	((agenda ""
  		 ((org-agenda-span 'day)
  		  (org-deadline-past-days 0)
  		  (org-agenda-deadline-faces
  		   '((1.0 . org-scheduled-today)
  		     (0.5 . org-scheduled)
  		     (0.0 . org-scheduled)))
  		  (org-agenda-overriding-header "Events")
  		  (org-super-agenda-groups
  		   '((:name "Events"
  			    :tag ("event"))
  		     (:discard (:anything))))
  		  (org-agenda-buffer-name "*Org Daily Agenda*")))
  	 
  	 (agenda ""
  		 ((org-agenda-span 'day)
  		  (org-agenda-overriding-header "Today")
  		  (org-super-agenda-groups
  		   '((:discard (:tag "event"))
  		     (:name "Fleeting notes"
  			    :and (:tag "fleeting"
  				       :not (:todo ("DONE")))
  			    :order 1)
  		     (:name "School"
  			    :and (:todo t
  					:tag ("schoolwork" "school" "내신")))
  		     (:name "Todo"
  			    :and (:todo ("TODO" "WORKING")
                                          :not (:tag "trivial")))
                       (:name "Trivial tasks"
  			    :and (:todo ("TODO" "WORKING")
  					:tag "trivial"))
  		     (:name "Journals"
  			    :tag "journal"
  			    :order 2)
  		     (:name "Today"
  			    :time-grid t
  			    :order 2))))))))
#+end_src
** Project agenda
#+begin_src elisp
  (add-to-list 'org-agenda-custom-commands
  	     '("p" "Projects"
  	       ((tags "current_project"
  		      ((org-agenda-prefix-format '((tags . "- ")))
  		       (org-agenda-overriding-header "Current projects")
  		       (org-agenda-remove-tags t)))
  		(tags "project|current_project"
  		      ((org-agenda-prefix-format '((tags . "- ")))
  		       (org-agenda-overriding-header "All projects")
  		       (org-agenda-remove-tags t))))))
#+end_src
* Capture templates
#+begin_src elisp
  (setq org-capture-templates nil)
#+end_src

Groups
#+begin_src elisp
  (add-to-list 'org-capture-templates '("f" "Fleeting"))
  (add-to-list 'org-capture-templates '("t" "Todo"))
  (add-to-list 'org-capture-templates '("p" "Problem"))
#+end_src

** Random thoughts (journaling)
Integrate with org-journal.
#+begin_src elisp
(defun me:org-journal-find-location ()
  (org-journal-new-entry t)
  (goto-char (point-max))
  (recenter-top-bottom 0))

(add-to-list 'org-capture-templates
	     `("c" "Random thought"
	       plain (function me:org-journal-find-location)
	       "** %T %?"))
#+end_src
** Zettelkasten entry
#+begin_src elisp
  (add-to-list 'org-capture-templates
  	     `("z" "Zettel"
  	       entry (file ,(expand-file-name "zk-current.org" me:note-zk-directory))
  	       "* %?"
  	       :jump-to-captured t))

  (defun me:org-capture-setup-zettel ()
    "Finish zettel captures."
    (when (equal (plist-get org-capture-current-plist :description) "Zettel")
      (if-let ((id (org-entry-get (point) "ID"))
               (buf (plist-get org-capture-current-plist :buffer)))
        (org-id-add-location id (buffer-file-name buf)))))

  (add-hook 'org-capture-before-finalize-hook #'me:org-capture-setup-zettel)
#+end_src
** Fleeting note
#+begin_src elisp
(add-to-list 'org-capture-templates
	     `("ff" "Fleeting note"
	       entry (file ,(expand-file-name "fleeting.org" me:note-root-directory))
	       "* IDEA %t %?"
	       :prepend t
	       :empty-lines-before 1))
#+end_src
** Fleeting note (elfeed)
#+begin_src elisp
  (add-to-list 'org-capture-templates
  	     `("fe" "Fleeting note (elfeed)"
  	       entry (file ,(expand-file-name "fleeting.org" me:note-root-directory))
  	       "* IDEA %t %?
  [[%:external-link][%:title]]"
  	       :prepend t))
#+end_src
** Event
#+begin_src elisp
  (add-to-list 'org-capture-templates
  	     `("e" "Event"
  	       entry (file ,(expand-file-name "events.org" me:note-root-directory))
  	       "* %? :event:"
  	       :prepend t
  	       :empty-lines-after 1))
#+end_src
** Todo item
#+begin_src elisp
(add-to-list 'org-capture-templates
	     `("tt" "Todo item"
	       entry (file ,(expand-file-name "todo.org" me:note-root-directory))
	       "* TODO %?"
	       :prepend t
	       :empty-lines-after 1))
#+end_src
** Baekjoon problem
#+begin_src elisp
  (add-to-list 'org-capture-templates
  	     `("pb" "Baekjoon problem"
  	      entry (file ,(expand-file-name "problems/baekjoon.org" me:note-root-directory))
  	      "* %t %^{id}. %^{title}
  [[https://www.acmicpc.net/problem/%\\1][Baekjoon]]
  ,** Ideas
  %?"
  	      :jump-to-captured t))
#+end_src
** Programmers problem
#+begin_src elisp
  (add-to-list 'org-capture-templates
  	     `("pp" "Programmers problem"
  	      entry (file ,(expand-file-name "problems/programmers.org" me:note-root-directory))
  	      "* %t %^{id}. %^{title}
  [[%^{url}][Programmers]]
  ,** Ideas
  %?"
  	      :jump-to-captured t))
#+end_src
** Captures
#+begin_src elisp
  (add-to-list 'org-capture-templates
  	     `("v" "Capture"
  	       entry (file ,(expand-file-name "captures.org" me:note-root-directory))
  	       "* %T %^{person} %^{title}
  %?"
  	       :prepend t))
#+end_src
** Todo in a project
#+begin_src elisp
  (defun me:todo-project-find-location ()
    (let ((project-file-name
  	 (read-file-name "Project file name: " me:note-project-directory "" t nil
  			 (lambda (name)
  			   (not (or (backup-file-name-p name)
  				    (auto-save-file-name-p name)))))))
      (unless (string-empty-p project-file-name)
        (find-file (expand-file-name project-file-name me:note-project-directory))    
        (goto-char (point-min))
        (unless (search-forward-regexp "^\\* Todo" nil t)
  	(goto-char (point-max))
  	(insert "* Todo")))))

  (add-to-list 'org-capture-templates
  	     `("tp" "Todo (in a project)"
  	       plain (function me:todo-project-find-location)
  	       "** TODO %?"))
#+end_src

* Projects
#+begin_src elisp
  (setq project-mode-line t)
#+end_src
* Dired
** Set ls command
#+begin_src elisp
  (setq dired-listing-switches "-hal")
#+end_src
** Delete by moving to trash
#+begin_src elisp
  (setq delete-by-moving-to-trash t)
#+end_src
* Rg
#+begin_src elisp
  (keymap-set rg-mode-map "C-n" 'rg-next-file)
  (keymap-set rg-mode-map "C-p" 'rg-prev-file)
  (rg-enable-default-bindings)
#+end_src
* Elfeed
** Key bindings
#+begin_src elisp
  (keymap-global-set "C-x w" 'elfeed)
#+end_src
** Default search filter
#+begin_src elisp
  (setq elfeed-search-filter "+unread")
#+end_src
** Load entries
#+begin_src elisp
  (load (expand-file-name "elfeed.el" user-emacs-directory))
  (elfeed-update)
#+end_src
** Unread current entry
#+begin_src elisp
  (defun me:elfeed-show-untag-unread ()
    (interactive)
    (elfeed-show-untag 'unread))

  (keymap-set elfeed-show-mode-map "r" 'me:elfeed-show-untag-unread)
#+end_src
** EWW Integration
#+begin_src elisp
  (defun me:elfeed-show-visit-eww ()
    "Visit the current entry with `eww'."
    (interactive)
    (when-let ((link (elfeed-entry-link elfeed-show-entry)))
      (eww link)))

  (keymap-set elfeed-show-mode-map "w" 'me:elfeed-show-visit-eww)
#+end_src
** Managing 'to read' entries
I often copy my elfeed entries to iPhone so I can read them while
walking around.

#+begin_src elisp
  (defvar me:elfeed-to-read-list nil
    "List for storing 'to read' entries.")
#+end_src

Add current entry to the list.
#+begin_src elisp
  (defun me:elfeed-show-add-to-read ()
    "Add current entry to 'to read' list."
    (interactive)
    (when-let ((entry elfeed-show-entry))
      (push entry me:elfeed-to-read-list)
      (message "Addded entry to to-read list")))

  (keymap-set elfeed-show-mode-map "a" 'me:elfeed-show-add-to-read)
#+end_src

Currently exporting is done by pushing the list to the mark ring.
#+begin_src elisp
  (defun me:elfeed-save-to-reads (keep-list)
    "Push 'to read' entries to the mark ring and clear the list.
  With a prefix argument, keep the list."
    (interactive "P")
    (kill-new (string-join
  	     (mapcar
  	      (lambda (entry) (elfeed-entry-link entry))
  	      me:elfeed-to-read-list) 
  	     "\n"))
    (unless keep-list
      (setq me:elfeed-to-read-list nil)))

  (keymap-set elfeed-search-mode-map "l" 'me:elfeed-save-to-reads)
#+end_src
* Shr / EWW
** Set max width for readability
#+begin_src elisp
(setq shr-max-width 80)
#+end_src
* Modus-themes
#+begin_src elisp
  (require-theme 'modus-themes)
#+end_src
** Key bindings
#+begin_src elisp
  (keymap-global-set "<f5>" 'modus-themes-rotate)
#+end_src
** Theme
#+begin_src elisp
  (setq modus-themes-common-palette-overrides modus-themes-preset-overrides-faint)
  (modus-themes-load-theme 'modus-vivendi-tinted)
#+end_src
* YaSnippet
#+begin_src elisp
(use-package yasnippet :ensure t)
#+end_src
* Evil
I don't enable it by default but it's nice to have
#+begin_src elisp
  (keymap-global-set "C-c e" 'evil-mode)
#+end_src
* Magit
** Org Mode bindings for section
#+begin_src elisp
  (keymap-set magit-section-mode-map "C-c C-u" 'magit-section-up)
  (keymap-set magit-section-mode-map "C-c C-n" 'magit-section-forward)
  (keymap-set magit-section-mode-map "C-c C-p" 'magit-section-backward)
  (keymap-set magit-section-mode-map "C-c C-f" 'magit-section-forward-sibling)
  (keymap-set magit-section-mode-map "C-c C-b" 'magit-section-backward-sibling)
#+end_src
* Vterm
* Man
** Manual program
#+begin_src elisp
  (defun me:man-toggle-remote ()
    "Toggles whether `man' uses Linux VM or current machine (Mac)
  for man command."
    (interactive)
    (setq-default manual-program (if (equal manual-program "man")
  				   "ssh vm-ubuntu man"
  				 "man"))
    (message (format "Manual program is now `%s'" manual-program)))
#+end_src
* Info
** Linux docs (VMs)
#+begin_src elisp
  (add-to-list 'Info-additional-directory-list
                "/ssh:vm-ubuntu:/usr/share/info")
#+end_src
* Markdown-mode
#+begin_src elisp
  (autoload 'markdown-mode "markdown-mode"
     "Major mode for editing Markdown files" t)
  (add-to-list 'auto-mode-alist
               '("\\.\\(?:md\\|markdown\\|mkd\\|mdown\\|mkdn\\|mdwn\\)\\'" . markdown-mode))

  (autoload 'gfm-mode "markdown-mode"
     "Major mode for editing GitHub Flavored Markdown files" t)
  (add-to-list 'auto-mode-alist '("README\\.md\\'" . gfm-mode))
#+end_src
* Eglot-booster
#+begin_src elisp
  (eglot-booster-mode)
#+end_src
* Minibuffer completion
#+begin_src elisp
  (remove-hook 'minibuffer-setup-hook #'company-mode)
#+end_src
* CDLaTeX
* Window setup
** Org mode source code editing
#+begin_src elisp
  (setq org-src-window-setup 'plain)
  (add-to-list 'display-buffer-alist
  	     `(,(lambda (&rest args) org-src-mode)
  	       (display-buffer-at-bottom)))
#+end_src
** Side window (bottom): Help and occur
#+begin_src elisp
  (add-to-list 'display-buffer-alist
  	     `((or
  		(derived-mode help-mode)
  		(derived-mode occur-mode))
  	       (display-buffer-in-side-window)
  	       (side . bottom)
  	       (window-height . 0.5)
  	       (post-command-select-window . t)))
#+end_src
** Side window (right): Info and apropos
#+begin_src elisp
  (add-to-list 'display-buffer-alist
  	     `((or
  		(derived-mode Info-mode)
  		(derived-mode apropos-mode))
  	       (display-buffer-reuse-mode-window display-buffer-in-side-window)
  	       (mode . Info-mode)
  	       (side . right)
  	       (window-width . 0.5)
  	       (post-command-select-window . t)))
#+end_src
** Man
#+begin_src elisp
  (setq Man-notify-method 'thrifty)

  (add-hook 'Man-mode-hook (lambda ()
  			  (set-window-dedicated-p (selected-window) nil)))

  (add-to-list 'display-buffer-alist
  	     `((derived-mode Man-mode)
  	       (display-buffer-reuse-mode-window display-buffer-in-side-window)
  	       (mode . Man-mode)
  	       (side . right)
  	       (window-width . 0.5)
  	       (post-command-select-window . t)))
#+end_src
** Zettelkasten
#+begin_src elisp
  (defun me:in-tab-p (name)
    "Return t if the current tab bar name is NAME."
    (string-equal name
        (if tab-bar-mode
  	  (cdr (assq 'name (tab-bar--current-tab))) "")))

  (add-to-list 'display-buffer-alist
  	     `((derived-mode me:zk-mode)
  	       (display-buffer-reuse-mode-window display-buffer-in-tab)
  	       (tab-name . "ZK")))

  (add-to-list 'display-buffer-alist
  	     `((and (lambda (&rest args)
  		      (me:in-tab-p "ZK"))
  		    (mode org-agenda-mode))
  	       (display-buffer-in-side-window)
  	       (side . right)
  	       (slot . 0)
  	       (window-width . 0.4)))
#+end_src
** Elfeed
#+begin_src elisp
  (add-to-list 'display-buffer-alist
  	     `("\\*elfeed-"
  	       (display-buffer-in-tab)
  	       (tab-name . "Elfeed")))
#+end_src
